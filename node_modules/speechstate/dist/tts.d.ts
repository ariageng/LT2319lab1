import { AzureSpeechCredentials, Agenda } from "./types";
interface MySpeechSynthesisUtterance extends SpeechSynthesisUtterance {
    new (s: string): any;
}
interface TTSInit {
    audioContext: AudioContext;
    azureCredentials: string | AzureSpeechCredentials;
    azureRegion: string;
    ttsDefaultVoice: string;
    ttsLexicon?: string;
}
interface TTSContext extends TTSInit {
    azureAuthorizationToken?: string;
    wsaTTS?: SpeechSynthesis;
    wsaVoice?: SpeechSynthesisVoice;
    wsaUtt?: MySpeechSynthesisUtterance;
    agenda?: Agenda;
    buffer?: string;
    currentVoice?: string;
    utteranceFromStream?: string;
}
interface TTSPonyfillInput {
    audioContext: AudioContext;
    azureRegion: string;
    azureAuthorizationToken: string;
}
type TTSEvent = {
    type: "PREPARE";
} | {
    type: "CONTROL";
} | {
    type: "STOP";
} | {
    type: "READY";
    value: {
        wsaTTS: SpeechSynthesis;
        wsaUtt: MySpeechSynthesisUtterance;
    };
} | {
    type: "ERROR";
} | {
    type: "SPEAK";
    value: Agenda;
} | {
    type: "TTS_STARTED";
} | {
    type: "STREAMING_CHUNK";
    value: string;
} | {
    type: "STREAMING_SET_VOICE";
    value: string;
} | {
    type: "STREAMING_DONE";
} | {
    type: "SPEAK_COMPLETE";
};
export declare const ttsMachine: import("xstate").StateMachine<TTSContext, TTSEvent, {
    [x: string]: import("xstate").ActorRef<import("xstate").CallbackSnapshot<{}>, import("xstate").EventObject, import("xstate").EventObject> | import("xstate").ActorRef<import("xstate").PromiseSnapshot<string, any>, {
        [k: string]: unknown;
        type: string;
    }, import("xstate").EventObject> | import("xstate").ActorRef<import("xstate").CallbackSnapshot<Agenda>, import("xstate").EventObject, import("xstate").EventObject> | import("xstate").ActorRef<import("xstate").CallbackSnapshot<TTSPonyfillInput>, null, import("xstate").EventObject>;
}, import("xstate").Values<{
    getToken: {
        src: "getToken";
        logic: import("xstate").PromiseActorLogic<string, any>;
        id: string;
    };
    createEventsFromStream: {
        src: "createEventsFromStream";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda>;
        id: string;
    };
    ponyfill: {
        src: "ponyfill";
        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput>;
        id: string;
    };
    start: {
        src: "start";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}>;
        id: string;
    };
}>, import("xstate").Values<{
    ttsStop: {
        type: "ttsStop";
        params: unknown;
    };
    addFiller: {
        type: "addFiller";
        params: {};
    };
    assignCurrentVoice: {
        type: "assignCurrentVoice";
        params: {};
    };
}>, import("xstate").Values<{
    bufferContainsUtterancePartReadyToBeSpoken: {
        type: "bufferContainsUtterancePartReadyToBeSpoken";
        params: unknown;
    };
    bufferIsNonEmpty: {
        type: "bufferIsNonEmpty";
        params: unknown;
    };
}>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
    Ready?: "Idle" | {
        BufferedSpeaker?: Required<{
            Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
            Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                Speak?: "Go" | "Paused";
            };
        }>;
        Speaking?: "Go" | "Paused";
    };
}, string, TTSInit, {}, import("xstate").EventObject, import("xstate").ResolveTypegenMeta<import("xstate").TypegenDisabled, TTSEvent, import("xstate").Values<{
    getToken: {
        src: "getToken";
        logic: import("xstate").PromiseActorLogic<string, any>;
        id: string;
    };
    createEventsFromStream: {
        src: "createEventsFromStream";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda>;
        id: string;
    };
    ponyfill: {
        src: "ponyfill";
        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput>;
        id: string;
    };
    start: {
        src: "start";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}>;
        id: string;
    };
}>, import("xstate").Values<{
    ttsStop: {
        type: "ttsStop";
        params: unknown;
    };
    addFiller: {
        type: "addFiller";
        params: {};
    };
    assignCurrentVoice: {
        type: "assignCurrentVoice";
        params: {};
    };
}>, import("xstate").Values<{
    bufferContainsUtterancePartReadyToBeSpoken: {
        type: "bufferContainsUtterancePartReadyToBeSpoken";
        params: unknown;
    };
    bufferIsNonEmpty: {
        type: "bufferIsNonEmpty";
        params: unknown;
    };
}>, "FILLER_DELAY", string, import("xstate").EventObject>>;
export {};
//# sourceMappingURL=tts.d.ts.map